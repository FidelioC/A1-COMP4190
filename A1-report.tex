\documentclass[12pt,fleqn]{article}
\usepackage[margin=0.5in]{geometry}
\usepackage{amsmath, amssymb}
\usepackage{enumitem}
\setlength{\mathindent}{0pt}
\allowdisplaybreaks

\title{COMP 4190 Assignment 1 Answer}
\author{Fidelio Ciandy, 7934456}
\date{}

\begin{document}
\maketitle

\section*{Problem 1}

For my first question, I have two functions with different purposes.

\begin{itemize}
  \item \textbf{TransformWord}
  \begin{itemize}
    \item This function performs the BFS.
    \item Starting from the begin word, it performs BFS by comparing the current word with the words in the word list.
    \item If the current word differs by a single letter, the new word is inserted into the queue and the sequence counter is incremented by 1.
    \item The visited word is added to a set to prevent circular loops.
    \item The loop continues until the end word is reached or the queue is empty.
  \end{itemize}

  \item \textbf{CheckAdjacentWords}
  \begin{itemize}
    \item This function will compare two strings and check whether those
    two strings differ by 1 letter or not
  \end{itemize}
\end{itemize}

\section*{Problem 2}
\section*{Problem 3}
\section*{Problem 4}
\section*{Problem 5}
\begin{enumerate}[label=(\alph*)]

\item 
The state $dp[i][j]$ represents the minimum number of edit operations to transform s into t. 
For each value in i and j, the table will save the previous minimum comparison between prefixes of $s[1..i]$ and $t[1..j]$,
and dp[m][n] will get the minimum value of the edit operations between the two strings.

For recurrence, where $i \geq 1, j \geq 1$:
\begin{itemize}
  \item $dp[i-1][j] + 1 \rightarrow$ this specify the delete operation, where last character of $s_i$ is deleted from $s[1..i]$, to transform $s[1..i-1]$ into $t[1..j]$
  \item $dp[i][j-1] + 1 \rightarrow$ this specify the insert operation, where we would like to insert character $t_j$ into string s, transforming $s[1..i]$ into $t[1..j-1]$.
  \item $dp[i-1][j-1] + l \rightarrow$ this specify the substitution operation, 
  \begin{itemize}
    \item where if $s_i = t_j$ we won't add 1, so cost is 0
    \item otherwise, if $s_i \neq t_j$ , we will add 1 to substitute the value
  \end{itemize}
\end{itemize}

\item 
The time complexity is $O(m \times n)$. 

Since the two strings $s$ and $t$ have lengths $m$ and $n$, $i$ ranges from 0 to $m$, and $j$ ranges from 0 to $n$
the dp table has $(m+1)(n+1)$ cells.

Futhermore, the calculation of each dp entry using the three recurrences (insertion, deletion, substitution), all of those operations are just accessing the array, 
thus this can be considered to be $O(1)$ as the time complexity.

Thus, since each entry is filled using constant number of operations $O(1)$ and each result is being stored in an $(m+1)(n+1)$ array.
Therefore, the time complexity is $O(m \times n)$. 

\item 
The memory/ space complexity of this DP implementation is $O(m \times n)$. 

Same reasoning as the previous part, since the two strings $s$ and $t$ have lengths $m$ and $n$, $i$ ranges from 0 to $m$, and $j$ ranges from 0 to $n$
the dp table has $(m+1)(n+1)$ cells. Thus, the memory complexity is $O(m \times n)$. 

\item 
From the recurrence formula, to fill a row in the DP array, we require only one row from the previous calculation. 
For instance for i=5, we only need to access 
  \begin{itemize}
    \item $dp[4][5] \rightarrow$ previous row, current column
    \item $dp[5][4] \rightarrow$ current row, previous column
    \item $dp[4][4] \rightarrow$ previous row, previous column
  \end{itemize}
Knowing how these calculation work, we could just create two separate array prev[] and curr[].
Where prev[] stores the values of row-1 and curr[] stores the current row i. Thus, this approach reduces the 
space complexity to $O(n)$.
\end{enumerate}

\section*{Problem 6}
\begin{align*}
(a)\;& \nabla_x f(x) = \tfrac12 (A + A^T)x - b \\
    & \text{Since A is symmetric, thus, } A = A^T \\
    & \nabla_x f(x) = Ax - b \\
(b)\;& x^* : \nabla f(x^*) = 0 \\
    & Ax^* - b = 0 \\
    & Ax^* = b \\
    & A^{-1} (A x^*) = A^{-1} b \\
    & I x^* = A^{-1} b\\
    & x^* = A^{-1} b\\
(c)\;&
\end{align*}

\section*{Problem 7}
\begin{align*}
(a)\;& \nabla f(x) = 2(x - 2)\\
(b)\;& x_{k+1} = x_k - \alpha \nabla f(X_k) \\
    & x_{k+1} = x_k - \alpha 2(x-2) \\
(c)\;& x^* : \nabla f(x^*) = 0 \\
    & \text{So, } x^* = 2  \\
(d)\;& \text{if step size $\alpha$ is too large: oscillations (no convergence)} \\
    & \text{if step size $\alpha$ is too small: slow convergence} \\
(e)\;& x_{k+1} = x_k - \alpha 2(x-2) \\
    & = x_k - 2\alpha x_k + 4\alpha \\
    & = (1 - 2\alpha)x_k + 4\alpha \\
    & \text{Example, let } (1-2\alpha) = b \\
    & x_1 = x_0 b + 4 \alpha \\
    & \\
    & x_2 = x_1 b + 4 \alpha \\
    & = (x_0 b + 4 \alpha) b + 4 \alpha \\
    & = x_0 b^2 + 4 \alpha b + 4 \alpha \\
    & = x_0 b^2 + 4 \alpha (b + 1) \\
    & \\
    & x_3 = x_2 b + 4 \alpha \\
    & = (x_0 b^2 + 4 \alpha (b+1)) b + 4\alpha \\
    & = (x_0 b^2 + 4 \alpha b + 4 \alpha) b + 4 \alpha \\
    & = x_0 b^3 + 4 \alpha b^2 + 4 \alpha b + 4 \alpha \\
    & = x_0 b^3 + 4 \alpha (b^2 + b + 1) \\
    & \\
    & \text{So, in general for } x_k\\
    & x_k = x_0 b^k + 4 \alpha (b^k + b^{k-1} + .... + 1) \\
    & (b^k + b^{k-1} + .... + 1) \text{ is a geometric sum}\\
    & \text{Thus, } \\
    & x_k = x_0 b^k + 4 \alpha \left(\frac{1-b^k}{1-b}\right)\\
    & = x_0 b^k + 4 \alpha \left( \frac{1-b^k}{2 \alpha}\right)\\
    & = x_0 b^k + 2 (1-b^k)\\
    & = x_0 b^k + 2 - 2b^k\\
    & = (x_0 - 2) b^k + 2 \\
    & = (1 - 2\alpha)^k (x_0 - 2) + 2 
      \qquad \text{... sub in } b = (1-2\alpha)\\
    & \\
    & x_k \text{ converges to } x^* == x_k \text{ converges to } 2 
      \text{, since } x^* = 2\\
    & \text{Thus, } x_k - 2 \text{ converges to } 0\\ 
    & \text{In other word, } (1 - 2\alpha)^k (x_0 - 2) \rightarrow 0\\
    & \text{Furthermore, } x_0 \neq x^* \rightarrow x_0 - 2 \neq 0\\
    & \text{Therefore, } (1-2\alpha)^k \rightarrow 0\\
\end{align*}

\end{document}
